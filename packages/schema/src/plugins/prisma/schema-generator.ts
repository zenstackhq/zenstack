import {
    AttributeArg,
    BooleanLiteral,
    ConfigArrayExpr,
    ConfigExpr,
    ConfigInvocationArg,
    DataModel,
    DataModelAttribute,
    DataModelField,
    DataModelFieldAttribute,
    DataModelFieldType,
    DataSource,
    Enum,
    EnumField,
    Expression,
    GeneratorDecl,
    InvocationExpr,
    isArrayExpr,
    isDataModel,
    isInvocationExpr,
    isLiteralExpr,
    isNullExpr,
    isReferenceExpr,
    isStringLiteral,
    LiteralExpr,
    Model,
    NumberLiteral,
    StringLiteral,
} from '@zenstackhq/language/ast';
import { match } from 'ts-pattern';
import { getIdFields } from '../../utils/ast-utils';

import { DELEGATE_AUX_RELATION_PREFIX, PRISMA_MINIMUM_VERSION } from '@zenstackhq/runtime';
import {
    getAttribute,
    getDMMF,
    getLiteral,
    getPrismaVersion,
    isAuthInvocation,
    isDelegateModel,
    isIdField,
    PluginError,
    PluginOptions,
    resolved,
    resolvePath,
    ZModelCodeGenerator,
} from '@zenstackhq/sdk';
import fs from 'fs';
import { writeFile } from 'fs/promises';
import { streamAst } from 'langium';
import { lowerCaseFirst } from 'lower-case-first';
import path from 'path';
import semver from 'semver';
import stripColor from 'strip-color';
import { upperCaseFirst } from 'upper-case-first';
import { name } from '.';
import { getStringLiteral } from '../../language-server/validator/utils';
import telemetry from '../../telemetry';
import { execSync } from '../../utils/exec-utils';
import { findPackageJson } from '../../utils/pkg-utils';
import {
    AttributeArgValue,
    ModelFieldType,
    AttributeArg as PrismaAttributeArg,
    AttributeArgValue as PrismaAttributeArgValue,
    ContainerDeclaration as PrismaContainerDeclaration,
    Model as PrismaDataModel,
    Enum as PrismaEnum,
    FieldAttribute as PrismaFieldAttribute,
    FieldReference as PrismaFieldReference,
    FieldReferenceArg as PrismaFieldReferenceArg,
    FunctionCall as PrismaFunctionCall,
    FunctionCallArg as PrismaFunctionCallArg,
    PrismaModel,
    ContainerAttribute as PrismaModelAttribute,
    PassThroughAttribute as PrismaPassThroughAttribute,
    SimpleField,
} from './prisma-builder';

const MODEL_PASSTHROUGH_ATTR = '@@prisma.passthrough';
const FIELD_PASSTHROUGH_ATTR = '@prisma.passthrough';

/**
 * Generates Prisma schema file
 */
export class PrismaSchemaGenerator {
    private zModelGenerator: ZModelCodeGenerator = new ZModelCodeGenerator();

    private readonly PRELUDE = `//////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                  //
// This file is automatically generated by ZenStack CLI and should not be manually updated. //
//////////////////////////////////////////////////////////////////////////////////////////////

`;

    private mode: 'logical' | 'physical' = 'physical';

    async generate(model: Model, options: PluginOptions) {
        const warnings: string[] = [];
        if (options.mode) {
            this.mode = options.mode as 'logical' | 'physical';
        }

        const prismaVersion = getPrismaVersion();
        if (prismaVersion && semver.lt(prismaVersion, PRISMA_MINIMUM_VERSION)) {
            warnings.push(
                `ZenStack requires Prisma version "${PRISMA_MINIMUM_VERSION}" or higher. Detected version is "${prismaVersion}".`
            );
        }

        const prisma = new PrismaModel();

        for (const decl of model.declarations) {
            switch (decl.$type) {
                case DataSource:
                    this.generateDataSource(prisma, decl as DataSource);
                    break;

                case Enum:
                    this.generateEnum(prisma, decl as Enum);
                    break;

                case DataModel:
                    this.generateModel(prisma, decl as DataModel);
                    break;

                case GeneratorDecl:
                    this.generateGenerator(prisma, decl as GeneratorDecl, options);
                    break;
            }
        }

        const outFile = options.output
            ? resolvePath(options.output as string, options)
            : getDefaultPrismaOutputFile(options.schemaPath);

        if (!fs.existsSync(path.dirname(outFile))) {
            fs.mkdirSync(path.dirname(outFile), { recursive: true });
        }
        await writeFile(outFile, this.PRELUDE + prisma.toString());

        if (options.format === true) {
            try {
                // run 'prisma format'
                await execSync(`npx prisma format --schema ${outFile}`, { stdio: 'ignore' });
            } catch {
                warnings.push(`Failed to format Prisma schema file`);
            }
        }

        const generateClient = options.generateClient !== false;

        if (generateClient) {
            let generateCmd = `npx prisma generate --schema "${outFile}"`;
            if (typeof options.generateArgs === 'string') {
                generateCmd += ` ${options.generateArgs}`;
            }
            try {
                // run 'prisma generate'
                await execSync(generateCmd, { stdio: 'ignore' });
            } catch {
                await this.trackPrismaSchemaError(outFile);
                try {
                    // run 'prisma generate' again with output to the console
                    await execSync(generateCmd);
                } catch {
                    // noop
                }
                throw new PluginError(name, `Failed to run "prisma generate"`);
            }
        }

        return warnings;
    }

    private async trackPrismaSchemaError(schema: string) {
        try {
            await getDMMF({ datamodel: fs.readFileSync(schema, 'utf-8') });
        } catch (err) {
            if (err instanceof Error) {
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                telemetry.track('prisma:error', { command: 'generate', message: stripColor(err.message) });
            }
        }
    }

    private generateDataSource(prisma: PrismaModel, dataSource: DataSource) {
        const fields: SimpleField[] = dataSource.fields.map((f) => ({
            name: f.name,
            text: this.configExprToText(f.value),
        }));
        prisma.addDataSource(dataSource.name, fields);
    }

    private configExprToText(expr: ConfigExpr) {
        if (isLiteralExpr(expr)) {
            return this.literalToText(expr);
        } else if (isInvocationExpr(expr)) {
            const fc = this.makeFunctionCall(expr);
            return fc.toString();
        } else {
            return this.configArrayToText(expr);
        }
    }

    private configArrayToText(expr: ConfigArrayExpr) {
        return (
            '[' +
            expr.items
                .map((item) => {
                    if (isLiteralExpr(item)) {
                        return this.literalToText(item);
                    } else {
                        return (
                            item.name +
                            (item.args.length > 0
                                ? '(' + item.args.map((arg) => this.configInvocationArgToText(arg)).join(', ') + ')'
                                : '')
                        );
                    }
                })
                .join(', ') +
            ']'
        );
    }

    private configInvocationArgToText(arg: ConfigInvocationArg) {
        return `${arg.name}: ${this.literalToText(arg.value)}`;
    }

    private literalToText(expr: LiteralExpr) {
        return JSON.stringify(expr.value);
    }

    private exprToText(expr: Expression) {
        return new ZModelCodeGenerator({ quote: 'double' }).generate(expr);
    }

    private generateGenerator(prisma: PrismaModel, decl: GeneratorDecl, options: PluginOptions) {
        const generator = prisma.addGenerator(
            decl.name,
            decl.fields.map((f) => ({ name: f.name, text: this.configExprToText(f.value) }))
        );

        // deal with configuring PrismaClient preview features
        const provider = generator.fields.find((f) => f.name === 'provider');
        if (provider?.text === JSON.stringify('prisma-client-js')) {
            const prismaVersion = getPrismaVersion();
            if (prismaVersion) {
                const previewFeatures = JSON.parse(
                    generator.fields.find((f) => f.name === 'previewFeatures')?.text ?? '[]'
                );

                if (!Array.isArray(previewFeatures)) {
                    throw new PluginError(name, 'option "previewFeatures" must be an array');
                }

                if (semver.lt(prismaVersion, '5.0.0')) {
                    // extendedWhereUnique feature is opt-in pre V5
                    if (!previewFeatures.includes('extendedWhereUnique')) {
                        previewFeatures.push('extendedWhereUnique');
                    }
                }

                if (semver.lt(prismaVersion, '5.0.0')) {
                    // fieldReference feature is opt-in pre V5
                    if (!previewFeatures.includes('fieldReference')) {
                        previewFeatures.push('fieldReference');
                    }
                }

                if (previewFeatures.length > 0) {
                    const curr = generator.fields.find((f) => f.name === 'previewFeatures');
                    if (!curr) {
                        generator.fields.push({ name: 'previewFeatures', text: JSON.stringify(previewFeatures) });
                    } else {
                        curr.text = JSON.stringify(previewFeatures);
                    }
                }
            }

            if (typeof options.overrideClientGenerationPath === 'string') {
                const output = generator.fields.find((f) => f.name === 'output');
                if (output) {
                    output.text = JSON.stringify(options.overrideClientGenerationPath);
                } else {
                    generator.fields.push({
                        name: 'output',
                        text: JSON.stringify(options.overrideClientGenerationPath),
                    });
                }
            }
        }
    }

    private generateModel(prisma: PrismaModel, decl: DataModel) {
        const model = decl.isView ? prisma.addView(decl.name) : prisma.addModel(decl.name);
        for (const field of decl.fields) {
            if (field.$inheritedFrom) {
                if (
                    // abstract inheritance is always kept
                    field.$inheritedFrom.isAbstract ||
                    // logical schema keeps all inherited fields
                    this.mode === 'logical' ||
                    // id fields are always kept
                    isIdField(field)
                ) {
                    this.generateModelField(model, field);
                }
            } else {
                this.generateModelField(model, field);
            }
        }

        for (const attr of decl.attributes.filter((attr) => this.isPrismaAttribute(attr))) {
            this.generateContainerAttribute(model, attr);
        }

        decl.attributes
            .filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr))
            .forEach((attr) => model.addComment('/// ' + this.zModelGenerator.generate(attr)));

        // user defined comments pass-through
        decl.comments.forEach((c) => model.addComment(c));

        // generate relation fields on base models linking to concrete models
        this.generateDelegateRelationForBase(model, decl);

        // generate reverse relation fields on concrete models
        this.generateDelegateRelationForConcrete(model, decl);

        // expand relations on other models that reference delegated models to concrete models
        this.expandPolymorphicRelations(model, decl);
    }

    private generateDelegateRelationForBase(model: PrismaDataModel, decl: DataModel) {
        if (this.mode !== 'physical') {
            return;
        }

        if (!isDelegateModel(decl)) {
            return;
        }

        // collect concrete models inheriting this model
        const concreteModels = decl.$container.declarations.filter(
            (d) => isDataModel(d) && d !== decl && d.superTypes.some((base) => base.ref === decl)
        );

        // generate an optional relation field in delegate base model to each concrete model
        concreteModels.forEach((concrete) => {
            const auxName = `${DELEGATE_AUX_RELATION_PREFIX}_${lowerCaseFirst(concrete.name)}`;
            model.addField(auxName, new ModelFieldType(concrete.name, false, true));
        });
    }

    private generateDelegateRelationForConcrete(model: PrismaDataModel, concreteDecl: DataModel) {
        if (this.mode !== 'physical') {
            return;
        }

        // generate a relation field for each delegated base model

        const baseModels = concreteDecl.superTypes
            .map((t) => t.ref)
            .filter((t): t is DataModel => !!t)
            .filter((t) => isDelegateModel(t));

        baseModels.forEach((base) => {
            const idFields = getIdFields(base);

            // add relation fields
            const relationField = `${DELEGATE_AUX_RELATION_PREFIX}_${lowerCaseFirst(base.name)}`;
            model.addField(relationField, base.name, [
                new PrismaFieldAttribute('@relation', [
                    new PrismaAttributeArg(
                        'fields',
                        new AttributeArgValue(
                            'Array',
                            idFields.map(
                                (idField) =>
                                    new AttributeArgValue('FieldReference', new PrismaFieldReference(idField.name))
                            )
                        )
                    ),
                    new PrismaAttributeArg(
                        'references',
                        new AttributeArgValue(
                            'Array',
                            idFields.map(
                                (idField) =>
                                    new AttributeArgValue('FieldReference', new PrismaFieldReference(idField.name))
                            )
                        )
                    ),
                    new PrismaAttributeArg(
                        'onDelete',
                        new AttributeArgValue('FieldReference', new PrismaFieldReference('Cascade'))
                    ),
                    new PrismaAttributeArg(
                        'onUpdate',
                        new AttributeArgValue('FieldReference', new PrismaFieldReference('Cascade'))
                    ),
                ]),
            ]);
        });
    }

    private expandPolymorphicRelations(model: PrismaDataModel, decl: DataModel) {
        if (this.mode !== 'logical') {
            return;
        }

        // the logical schema needs to expand relations to the delegate models to concrete ones

        // for the given model, find all concrete models that have relation to it,
        // and generate an auxiliary opposite relation field
        decl.fields.forEach((f) => {
            const fieldType = f.type.reference?.ref;
            if (!isDataModel(fieldType)) {
                return;
            }

            // find concrete models that inherit from this field's model type
            const concreteModels = decl.$container.declarations.filter(
                (d) => isDataModel(d) && isDescendantOf(d, fieldType)
            );

            concreteModels.forEach((concrete) => {
                const relationField = model.addField(
                    `${DELEGATE_AUX_RELATION_PREFIX}_${lowerCaseFirst(concrete.name)}`,
                    new ModelFieldType(concrete.name, f.type.array, f.type.optional)
                );
                const relAttr = getAttribute(f, '@relation');
                if (relAttr) {
                    const fieldsArg = relAttr.args.find((arg) => arg.name === 'fields');
                    if (fieldsArg) {
                        const idFields = getIdFields(fieldType);
                        idFields.forEach((idField) => {
                            model.addField(
                                `${DELEGATE_AUX_RELATION_PREFIX}_${lowerCaseFirst(concrete.name)}${upperCaseFirst(
                                    idField.name
                                )}`,
                                idField.type.type!
                            );
                        });

                        const args = new AttributeArgValue(
                            'Array',
                            idFields.map(
                                (idField) =>
                                    new AttributeArgValue('FieldReference', new PrismaFieldReference(idField.name))
                            )
                        );
                        relationField.attributes.push(
                            new PrismaFieldAttribute('@relation', [
                                new PrismaAttributeArg('fields', args),
                                new PrismaAttributeArg('references', args),
                            ])
                        );
                    } else {
                        relationField.attributes.push(this.makeFieldAttribute(relAttr as DataModelFieldAttribute));
                    }
                }
            });
        });
    }

    private isPrismaAttribute(attr: DataModelAttribute | DataModelFieldAttribute) {
        if (!attr.decl.ref) {
            return false;
        }
        const attrDecl = resolved(attr.decl);
        return (
            !!attrDecl.attributes.find((a) => a.decl.ref?.name === '@@@prisma') ||
            // the special pass-through attribute
            attrDecl.name === MODEL_PASSTHROUGH_ATTR ||
            attrDecl.name === FIELD_PASSTHROUGH_ATTR
        );
    }

    private getUnsupportedFieldType(fieldType: DataModelFieldType) {
        if (fieldType.unsupported) {
            const value = getStringLiteral(fieldType.unsupported.value);
            if (value) {
                return `Unsupported("${value}")`;
            } else {
                return undefined;
            }
        } else {
            return undefined;
        }
    }

    private generateModelField(model: PrismaDataModel, field: DataModelField, addToFront = false) {
        const fieldType =
            field.type.type || field.type.reference?.ref?.name || this.getUnsupportedFieldType(field.type);
        if (!fieldType) {
            throw new PluginError(name, `Field type is not resolved: ${field.$container.name}.${field.name}`);
        }

        const type = new ModelFieldType(fieldType, field.type.array, field.type.optional);

        const attributes = field.attributes
            .filter((attr) => this.isPrismaAttribute(attr))
            // `@default` with `auth()` is handled outside Prisma
            .filter((attr) => !this.isDefaultWithAuth(attr))
            .filter(
                (attr) =>
                    // when building physical schema, exclude `@default` for id fields inherited from delegate base
                    !(
                        this.mode === 'physical' &&
                        isIdField(field) &&
                        this.isInheritedFromDelegate(field) &&
                        attr.decl.$refText === '@default'
                    )
            )
            .map((attr) => this.makeFieldAttribute(attr));

        const nonPrismaAttributes = field.attributes.filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr));

        const documentations = nonPrismaAttributes.map((attr) => '/// ' + this.zModelGenerator.generate(attr));

        const result = model.addField(field.name, type, attributes, documentations, addToFront);

        // user defined comments pass-through
        field.comments.forEach((c) => result.addComment(c));
    }

    private isInheritedFromDelegate(field: DataModelField) {
        return field.$inheritedFrom && isDelegateModel(field.$inheritedFrom);
    }

    private isDefaultWithAuth(attr: DataModelFieldAttribute) {
        if (attr.decl.ref?.name !== '@default') {
            return false;
        }

        const expr = attr.args[0]?.value;
        if (!expr) {
            return false;
        }

        // find `auth()` in default value expression
        return streamAst(expr).some(isAuthInvocation);
    }

    private makeFieldAttribute(attr: DataModelFieldAttribute) {
        const attrName = resolved(attr.decl).name;
        if (attrName === FIELD_PASSTHROUGH_ATTR) {
            const text = getLiteral<string>(attr.args[0].value);
            if (text) {
                return new PrismaPassThroughAttribute(text);
            } else {
                throw new PluginError(name, `Invalid arguments for ${FIELD_PASSTHROUGH_ATTR} attribute`);
            }
        } else {
            return new PrismaFieldAttribute(
                attrName,
                attr.args.map((arg) => this.makeAttributeArg(arg))
            );
        }
    }

    private makeAttributeArg(arg: AttributeArg): PrismaAttributeArg {
        return new PrismaAttributeArg(arg.name, this.makeAttributeArgValue(arg.value));
    }

    private makeAttributeArgValue(node: Expression): PrismaAttributeArgValue {
        if (isLiteralExpr(node)) {
            const argType = match(node.$type)
                .with(StringLiteral, () => 'String' as const)
                .with(NumberLiteral, () => 'Number' as const)
                .with(BooleanLiteral, () => 'Boolean' as const)
                .exhaustive();
            return new PrismaAttributeArgValue(argType, node.value);
        } else if (isArrayExpr(node)) {
            return new PrismaAttributeArgValue(
                'Array',
                new Array(...node.items.map((item) => this.makeAttributeArgValue(item)))
            );
        } else if (isReferenceExpr(node)) {
            return new PrismaAttributeArgValue(
                'FieldReference',
                new PrismaFieldReference(
                    resolved(node.target).name,
                    node.args.map((arg) => new PrismaFieldReferenceArg(arg.name, this.exprToText(arg.value)))
                )
            );
        } else if (isInvocationExpr(node)) {
            // invocation
            return new PrismaAttributeArgValue('FunctionCall', this.makeFunctionCall(node));
        } else {
            throw new PluginError(name, `Unsupported attribute argument expression type: ${node.$type}`);
        }
    }

    makeFunctionCall(node: InvocationExpr): PrismaFunctionCall {
        return new PrismaFunctionCall(
            resolved(node.function).name,
            node.args.map((arg) => {
                const val = match(arg.value)
                    .when(isStringLiteral, (v) => `"${v.value}"`)
                    .when(isLiteralExpr, (v) => v.value.toString())
                    .when(isNullExpr, () => 'null')
                    .otherwise(() => {
                        throw new PluginError(name, 'Function call argument must be literal or null');
                    });

                return new PrismaFunctionCallArg(val);
            })
        );
    }

    private generateContainerAttribute(container: PrismaContainerDeclaration, attr: DataModelAttribute) {
        const attrName = resolved(attr.decl).name;
        if (attrName === MODEL_PASSTHROUGH_ATTR) {
            const text = getLiteral<string>(attr.args[0].value);
            if (text) {
                container.attributes.push(new PrismaPassThroughAttribute(text));
            }
        } else {
            container.attributes.push(
                new PrismaModelAttribute(
                    attrName,
                    attr.args.map((arg) => this.makeAttributeArg(arg))
                )
            );
        }
    }

    private generateEnum(prisma: PrismaModel, decl: Enum) {
        const _enum = prisma.addEnum(decl.name);

        for (const field of decl.fields) {
            this.generateEnumField(_enum, field);
        }

        for (const attr of decl.attributes.filter((attr) => this.isPrismaAttribute(attr))) {
            this.generateContainerAttribute(_enum, attr);
        }

        decl.attributes
            .filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr))
            .forEach((attr) => _enum.addComment('/// ' + this.zModelGenerator.generate(attr)));

        // user defined comments pass-through
        decl.comments.forEach((c) => _enum.addComment(c));
    }

    private generateEnumField(_enum: PrismaEnum, field: EnumField) {
        const attributes = field.attributes
            .filter((attr) => this.isPrismaAttribute(attr))
            .map((attr) => this.makeFieldAttribute(attr));

        const nonPrismaAttributes = field.attributes.filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr));

        const documentations = nonPrismaAttributes.map((attr) => '/// ' + this.zModelGenerator.generate(attr));
        _enum.addField(field.name, attributes, documentations);
    }
}

function isDescendantOf(model: DataModel, superModel: DataModel): boolean {
    return model.superTypes.some((s) => s.ref === superModel || isDescendantOf(s.ref!, superModel));
}

export function getDefaultPrismaOutputFile(schemaPath: string) {
    // handle override from package.json
    const pkgJsonPath = findPackageJson(path.dirname(schemaPath));
    if (pkgJsonPath) {
        const pkgJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf-8'));
        if (typeof pkgJson?.zenstack?.prisma === 'string') {
            if (path.isAbsolute(pkgJson.zenstack.prisma)) {
                return pkgJson.zenstack.prisma;
            } else {
                // resolve relative to package.json
                return path.resolve(path.dirname(pkgJsonPath), pkgJson.zenstack.prisma);
            }
        }
    }

    return resolvePath('./prisma/schema.prisma', { schemaPath });
}
