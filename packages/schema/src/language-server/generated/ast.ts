/******************************************************************************
 * This file was generated by langium-cli 0.4.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode, TypeMetaData } from 'langium';

export type Expression = ArrayExpr | BinaryExpr | EnumMemberExpr | InvocationExpr | LiteralExpr | ReferenceExpr | UnaryExpr;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type ReferenceTarget = DataModelField | Function | FunctionParam;

export const ReferenceTarget = 'ReferenceTarget';

export function isReferenceTarget(item: unknown): item is ReferenceTarget {
    return reflection.isInstance(item, ReferenceTarget);
}

export type TypeDeclaration = DataModel | Enum;

export const TypeDeclaration = 'TypeDeclaration';

export function isTypeDeclaration(item: unknown): item is TypeDeclaration {
    return reflection.isInstance(item, TypeDeclaration);
}

export interface ArrayExpr extends AstNode {
    readonly $container: ArrayExpr | BinaryExpr | DataModelAttribute | DataModelFieldAttribute | DataSourceField | Function | InvocationExpr | UnaryExpr;
    items: Array<Expression>
}

export const ArrayExpr = 'ArrayExpr';

export function isArrayExpr(item: unknown): item is ArrayExpr {
    return reflection.isInstance(item, ArrayExpr);
}

export interface Attribute extends AstNode {
    readonly $container: Model;
    name: string
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface BinaryExpr extends AstNode {
    readonly $container: ArrayExpr | BinaryExpr | DataModelAttribute | DataModelFieldAttribute | DataSourceField | Function | InvocationExpr | UnaryExpr;
    left: Expression
    operator: '!=' | '&&' | '*' | '+' | '-' | '/' | '<' | '<=' | '==' | '>' | '>=' | '||'
    right: Expression
}

export const BinaryExpr = 'BinaryExpr';

export function isBinaryExpr(item: unknown): item is BinaryExpr {
    return reflection.isInstance(item, BinaryExpr);
}

export interface DataModel extends AstNode {
    readonly $container: Model;
    attributes: Array<DataModelAttribute>
    fields: Array<DataModelField>
    name: string
}

export const DataModel = 'DataModel';

export function isDataModel(item: unknown): item is DataModel {
    return reflection.isInstance(item, DataModel);
}

export interface DataModelAttribute extends AstNode {
    readonly $container: DataModel;
    args: Array<Expression>
    decl: Reference<Attribute>
}

export const DataModelAttribute = 'DataModelAttribute';

export function isDataModelAttribute(item: unknown): item is DataModelAttribute {
    return reflection.isInstance(item, DataModelAttribute);
}

export interface DataModelField extends AstNode {
    readonly $container: DataModel;
    attributes: Array<DataModelFieldAttribute>
    fieldType: DataModelFieldType
    name: string
}

export const DataModelField = 'DataModelField';

export function isDataModelField(item: unknown): item is DataModelField {
    return reflection.isInstance(item, DataModelField);
}

export interface DataModelFieldAttribute extends AstNode {
    readonly $container: DataModelField;
    args: Array<Expression>
    decl: Reference<Attribute>
}

export const DataModelFieldAttribute = 'DataModelFieldAttribute';

export function isDataModelFieldAttribute(item: unknown): item is DataModelFieldAttribute {
    return reflection.isInstance(item, DataModelFieldAttribute);
}

export interface DataModelFieldType extends AstNode {
    readonly $container: DataModelField;
    array: boolean
    optional: boolean
    reference?: Reference<TypeDeclaration>
    type?: 'Boolean' | 'DateTime' | 'Float' | 'Int' | 'JSON' | 'String'
}

export const DataModelFieldType = 'DataModelFieldType';

export function isDataModelFieldType(item: unknown): item is DataModelFieldType {
    return reflection.isInstance(item, DataModelFieldType);
}

export interface DataSource extends AstNode {
    readonly $container: Model;
    fields: Array<DataSourceField>
    name: string
}

export const DataSource = 'DataSource';

export function isDataSource(item: unknown): item is DataSource {
    return reflection.isInstance(item, DataSource);
}

export interface DataSourceField extends AstNode {
    readonly $container: DataSource;
    name: string
    value: Expression
}

export const DataSourceField = 'DataSourceField';

export function isDataSourceField(item: unknown): item is DataSourceField {
    return reflection.isInstance(item, DataSourceField);
}

export interface Enum extends AstNode {
    readonly $container: Model;
    fields: Array<EnumField>
    name: string
}

export const Enum = 'Enum';

export function isEnum(item: unknown): item is Enum {
    return reflection.isInstance(item, Enum);
}

export interface EnumField extends AstNode {
    readonly $container: Enum;
    value: string
}

export const EnumField = 'EnumField';

export function isEnumField(item: unknown): item is EnumField {
    return reflection.isInstance(item, EnumField);
}

export interface EnumMemberExpr extends AstNode {
    readonly $container: ArrayExpr | BinaryExpr | DataModelAttribute | DataModelFieldAttribute | DataSourceField | Function | InvocationExpr | UnaryExpr;
    decl: Reference<Enum>
    member: string
}

export const EnumMemberExpr = 'EnumMemberExpr';

export function isEnumMemberExpr(item: unknown): item is EnumMemberExpr {
    return reflection.isInstance(item, EnumMemberExpr);
}

export interface Function extends AstNode {
    readonly $container: Model;
    expression: Expression
    name: string
    params: Array<FunctionParam>
}

export const Function = 'Function';

export function isFunction(item: unknown): item is Function {
    return reflection.isInstance(item, Function);
}

export interface FunctionParam extends AstNode {
    readonly $container: Function;
    name: string
}

export const FunctionParam = 'FunctionParam';

export function isFunctionParam(item: unknown): item is FunctionParam {
    return reflection.isInstance(item, FunctionParam);
}

export interface InvocationExpr extends AstNode {
    readonly $container: ArrayExpr | BinaryExpr | DataModelAttribute | DataModelFieldAttribute | DataSourceField | Function | InvocationExpr | UnaryExpr;
    args: Array<Expression>
    function: string
}

export const InvocationExpr = 'InvocationExpr';

export function isInvocationExpr(item: unknown): item is InvocationExpr {
    return reflection.isInstance(item, InvocationExpr);
}

export interface LiteralExpr extends AstNode {
    readonly $container: ArrayExpr | BinaryExpr | DataModelAttribute | DataModelFieldAttribute | DataSourceField | Function | InvocationExpr | UnaryExpr;
    value: boolean | number | string
}

export const LiteralExpr = 'LiteralExpr';

export function isLiteralExpr(item: unknown): item is LiteralExpr {
    return reflection.isInstance(item, LiteralExpr);
}

export interface Model extends AstNode {
    attributes: Array<Attribute>
    datasources: Array<DataSource>
    enums: Array<Enum>
    functions: Array<Function>
    models: Array<DataModel>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface ReferenceExpr extends AstNode {
    readonly $container: ArrayExpr | BinaryExpr | DataModelAttribute | DataModelFieldAttribute | DataSourceField | Function | InvocationExpr | UnaryExpr;
    target: Reference<ReferenceTarget>
}

export const ReferenceExpr = 'ReferenceExpr';

export function isReferenceExpr(item: unknown): item is ReferenceExpr {
    return reflection.isInstance(item, ReferenceExpr);
}

export interface UnaryExpr extends AstNode {
    readonly $container: ArrayExpr | BinaryExpr | DataModelAttribute | DataModelFieldAttribute | DataSourceField | Function | InvocationExpr | UnaryExpr;
    arg: Expression
    operator: '!' | '+' | '-'
}

export const UnaryExpr = 'UnaryExpr';

export function isUnaryExpr(item: unknown): item is UnaryExpr {
    return reflection.isInstance(item, UnaryExpr);
}

export type ZModelAstType = 'ArrayExpr' | 'Attribute' | 'BinaryExpr' | 'DataModel' | 'DataModelAttribute' | 'DataModelField' | 'DataModelFieldAttribute' | 'DataModelFieldType' | 'DataSource' | 'DataSourceField' | 'Enum' | 'EnumField' | 'EnumMemberExpr' | 'Expression' | 'Function' | 'FunctionParam' | 'InvocationExpr' | 'LiteralExpr' | 'Model' | 'ReferenceExpr' | 'ReferenceTarget' | 'TypeDeclaration' | 'UnaryExpr';

export type ZModelAstReference = 'DataModelAttribute:decl' | 'DataModelFieldAttribute:decl' | 'DataModelFieldType:reference' | 'EnumMemberExpr:decl' | 'ReferenceExpr:target';

export class ZModelAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['ArrayExpr', 'Attribute', 'BinaryExpr', 'DataModel', 'DataModelAttribute', 'DataModelField', 'DataModelFieldAttribute', 'DataModelFieldType', 'DataSource', 'DataSourceField', 'Enum', 'EnumField', 'EnumMemberExpr', 'Expression', 'Function', 'FunctionParam', 'InvocationExpr', 'LiteralExpr', 'Model', 'ReferenceExpr', 'ReferenceTarget', 'TypeDeclaration', 'UnaryExpr'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case ArrayExpr:
            case BinaryExpr:
            case EnumMemberExpr:
            case InvocationExpr:
            case LiteralExpr:
            case ReferenceExpr:
            case UnaryExpr: {
                return this.isSubtype(Expression, supertype);
            }
            case DataModel:
            case Enum: {
                return this.isSubtype(TypeDeclaration, supertype);
            }
            case DataModelField:
            case Function:
            case FunctionParam: {
                return this.isSubtype(ReferenceTarget, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: ZModelAstReference): string {
        switch (referenceId) {
            case 'DataModelAttribute:decl': {
                return Attribute;
            }
            case 'DataModelFieldAttribute:decl': {
                return Attribute;
            }
            case 'DataModelFieldType:reference': {
                return TypeDeclaration;
            }
            case 'EnumMemberExpr:decl': {
                return Enum;
            }
            case 'ReferenceExpr:target': {
                return ReferenceTarget;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'ArrayExpr': {
                return {
                    name: 'ArrayExpr',
                    mandatory: [
                        { name: 'items', type: 'array' }
                    ]
                };
            }
            case 'DataModel': {
                return {
                    name: 'DataModel',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'fields', type: 'array' }
                    ]
                };
            }
            case 'DataModelAttribute': {
                return {
                    name: 'DataModelAttribute',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'DataModelField': {
                return {
                    name: 'DataModelField',
                    mandatory: [
                        { name: 'attributes', type: 'array' }
                    ]
                };
            }
            case 'DataModelFieldAttribute': {
                return {
                    name: 'DataModelFieldAttribute',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'DataModelFieldType': {
                return {
                    name: 'DataModelFieldType',
                    mandatory: [
                        { name: 'array', type: 'boolean' },
                        { name: 'optional', type: 'boolean' }
                    ]
                };
            }
            case 'DataSource': {
                return {
                    name: 'DataSource',
                    mandatory: [
                        { name: 'fields', type: 'array' }
                    ]
                };
            }
            case 'Enum': {
                return {
                    name: 'Enum',
                    mandatory: [
                        { name: 'fields', type: 'array' }
                    ]
                };
            }
            case 'Function': {
                return {
                    name: 'Function',
                    mandatory: [
                        { name: 'params', type: 'array' }
                    ]
                };
            }
            case 'InvocationExpr': {
                return {
                    name: 'InvocationExpr',
                    mandatory: [
                        { name: 'args', type: 'array' }
                    ]
                };
            }
            case 'Model': {
                return {
                    name: 'Model',
                    mandatory: [
                        { name: 'attributes', type: 'array' },
                        { name: 'datasources', type: 'array' },
                        { name: 'enums', type: 'array' },
                        { name: 'functions', type: 'array' },
                        { name: 'models', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ZModelAstReflection();
